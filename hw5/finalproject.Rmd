---
title: "DATA 622 Final Project - Image Classification"
author: "Mael Illien, Dhairav Chhatbar, Santosh Manjrekar"
date: "5/7/2021"
output: 
  html_document:
    code_folding: hide
    theme: cosmo
    highlight: tango
    toc: true
    number_section: false
    toc_float:
      collapsed: true
      smooth_scroll: true
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup

```{r message=FALSE, warning=FALSE}
library(skimr)
library(tidyverse)
library(gridExtra)
library(readr)
library(dplyr)
library(caret)
library(naivebayes)
library(factoextra) # For PCA plots
library(e1071)
library(Rtsne)
library(RColorBrewer)
library(gbm)
library(randomForest)
```

# Data Description

```{r message=FALSE, warning=FALSE}
mnist_raw <- read_csv("https://pjreddie.com/media/files/mnist_train.csv", col_names = FALSE)
mnist_raw_test <- read_csv("https://pjreddie.com/media/files/mnist_test.csv", col_names = FALSE)
```

The MNIST dataset is a compilation of handwritten digits which have been digitzed for use in supervised machine learning classification applications. The datset is fairly large with 60,000 observations where each observation is a handwritten digit from various subjects. As a result of this diversity, each handwritten digit of the same number can have differences due to penmanship style and variation within the same penmanship style.

Each handwritten digit is on a 28x28 pixel image. The digits per observation range from 0 to 9 where each observation/digit in the 28x28 pixel have had their size normalized and have been centered on the image canvas. 

Below is a sample of observations from the dataset. Note that the images are grayscale. Each every pixel on the canvas is represented by a integer range from 0 to 255, where 0 means the pixel is completely white and 255 means the pixel is completely black, the ranges from 1 to 254 are the various shades of the color gray. Since each image is 28x28 pixels in size, then each image can be represented by a 28x28 size matrix. 

To represent each matrix as an observation, each digit matrix has been flattened (converting from a multidimensional array to a single dimensional array) such that each observation is a integer list of ($28x28=784$) length 784, where each value in the list is the pixel value ranging from 0 to 255. This list has an additional value which contains a number from the range 0-9 containing the label value of the number represented by the image, bringing the length per observation to 785.  
  
Bringing this all together, the dataset has 60,000 observations, 784 features and 1 classification label. The dataset of digital images is now represented in a format suitable for analysis and modeling. To ease computation time, a subset of 5,000 observations was used in this modeling exercise.

```{r}
# Reduce the dataset down from 60,000 observations
mnist_subset <- mnist_raw %>%  head(5000)
# Relabel X1 and add instance number
mnist_subset <- mnist_subset  %>%  rename(label = X1) %>%  mutate(instance = row_number())
# Split dataset into X and y
X <- mnist_subset %>% select(contains('X'))
y <- mnist_subset$label 
# Display example instances
pixels_gathered <- mnist_subset %>%  gather(pixel, value, -label, -instance) %>%  tidyr::extract(pixel, "pixel", "(\\d+)", convert = TRUE) %>%  mutate(pixel = pixel - 2, x = pixel %% 28, y = 28 - pixel %/% 28)
theme_set(theme_light())
pixels_gathered %>%  filter(instance <=12) %>%  ggplot(aes(x, y, fill = value)) +  geom_tile() +  facet_wrap(~ instance + label) + scale_fill_gradient(low = "white", high = "black")
```

# Data Exploration

The distribution of the draw of 5,000 samples from dataset is displayed below. The distribution is fairly even, though we note that the number 2 is largely more represented than the number 5. The majority of points are either 0 (white) or 255 (black). Most values are not useful which suggest that some dimensionality reduction methods might be useful. 

```{r}
plot1 <- ggplot(mnist_subset, aes(label)) + geom_bar(fill="steelblue")
plot2 <- ggplot(pixels_gathered, aes(value)) +  geom_histogram(bins=256, fill="steelblue")
grid.arrange(plot1, plot2, ncol=2)
```

The figure below is a representation of the average pixels values for the 10 digits in the dataset. The fuzzy, grey areas are zones of high variability. We can notice the most variability in the tails and long strokes of some digits. On the other hand, some digits such as 0 and 1 have highler pixel concrentrations. 

```{r message=FALSE, warning=FALSE}
pixel_summary <- pixels_gathered %>%  group_by(x, y, label) %>%  summarize(mean_value = mean(value)) %>%  ungroup()
pixel_summary %>%  ggplot(aes(x, y, fill = mean_value)) +  geom_tile() +  scale_fill_gradient2(low = "white", high = "black", mid = "gray", midpoint = 127.5) +  facet_wrap(~ label, nrow = 2) +  labs(title = "Average value of each pixel in 10 MNIST digits", fill = "Average value") +  theme_void()
```


```{r}
x <- 8
cat("Label: ", mnist_raw$X1[x], "\n")
m <- t(matrix(mnist_raw[x,] %>% select(-X1), ncol = 28))
dimnames(m) <-list(rep("", dim(m)[1]), rep("", dim(m)[2]))
m

```


T-SNE Visual
```{r}

tsne_v <- Rtsne(as.matrix(select(mnist_subset, -label)), dims=2, check_duplicates = FALSE, pca = TRUE, pca_scale = FALSE, theta = 0.1 , perplexity = 45)
tsne_coords = data.frame(X=tsne_v$Y[,1], Y=tsne_v$Y[,2], Label=as.factor(mnist_subset$label))
ggplot(tsne_coords, aes(x=X, y=Y, color=Label)) + geom_point(size = 1) + scale_color_brewer(palette = "Set3") + theme_dark()
```


# Data Processing

## Dimensionality Reduction

Two dimensionality reduction methods are explore, Near-Zero Variance (NVZ) and Principal Component Analysis (PCA).

### Near Zero Variance

The near zero variance method looks at the distribution of variables across the dataset and identifies features with low percentages of unique values. These variables are essentially constants and contain no information. As previously shown, the dataset is sparse and the majority of the pixels are always zero. The resulsting dataset retains only 250 variables. The figure below is a representation of the most variable pixels on the image canvas.

```{r}
nonzero_var <- nearZeroVar(X, saveMetrics = FALSE)
image(matrix(1:784 %in% nonzero_var, 28, 28))
```

```{r}
X <- mnist_subset[ , -nonzero_var]
X <- select(X, -instance)
```

### PCA

Principal Component Analysis (PCA) is a dimensionality reduction technique where a dataset is transformed to use p eigenvectors of the covariance matrix instead of the original number of predictors n, where p < n. The number of eigenvectors p is selected by looking at the sorted eigenvalues and determining a threshold percentage of variance explained and the resulting p.  

The method seeks to project the data into a lower dimensional space where each axis (or principal component) captures the most variability in the data subject to the condition of being uncorrelated to the other axes. This last condition is important for dimensionality reduction in the sense that large datasets can contain many correlated variables which hold no additional information.

```{r}
pca <- prcomp(select(mnist_subset, -label), center = TRUE, scale = FALSE)
qqnorm(pca[["x"]][,1])
```

```{r}
pca %>% get_eigenvalue() %>% head(10)
```

```{r}
pca %>% fviz_eig(addlabels = TRUE)
```


```{r}
get_eigenvalue(pca) %>% filter(eigenvalue > 1)
```

```{r}
reduced_dim_95 <- get_eigenvalue(pca) %>% filter(cumulative.variance.percent < 95.02)
reduced_dim_95

#mnist_pca_reduced <- cbind(as.data.frame(pca$x[,c(1:nrow(reduced_dim_95))]), Label = mnist_raw$X1)
mnist_pca_reduced <- as.data.frame(pca$x[,c(1:nrow(reduced_dim_95))])
head(mnist_pca_reduced)
```

# Modeling


```{r message=FALSE, warning=FALSE}
# Data Partitioning
set.seed(622)
trainIndex <- createDataPartition(y, p = .8, list = FALSE, times = 1)
X_train <- X[trainIndex,]
y_train <- y[trainIndex]
X_test <- X[-trainIndex,]
y_test <- y[-trainIndex]
y_train <- as.factor(y_train)
y_test <- as.factor(y_test)
```

```{r}
performance_df <- data.frame(Model = NULL, Accuracy = NULL, Kappa = NULL)
```


## KNN

K-Nearest Neighbors (KNN) algorithm is non-parametric in the sense that no coefficients are estimated. Instead KNN uses distances between observation points and identifies the k closest datapoints to determine the classification. It is typical to scale the variables in order to even out the influence of variables with large values. In our case, all variables are already on the same scale so no additional processing is required.

Cross-validation over 3 folds and various values of k are used in determining the optimal parameter. The highest accuracy on the training set is reached used a model with only a single neighbor. The classification results on the test set are displayed below. This 1-NN model reaches an accuracy of 94.9%.

```{r message=FALSE, warning=FALSE}
trControl <- trainControl(method  = "cv", number  = 3)
knn.fit <- train(X_train, y_train,
             method     = "knn",
             tuneGrid   = expand.grid(k = 1:5),
             trControl  = trControl)

plot(knn.fit)
```

```{r}
knnPredict <- predict(knn.fit, newdata = X_test) 
knn_cm <- confusionMatrix(knnPredict, y_test)
perf_knn <- data.frame(Model = "KNN", Accuracy = knn_cm$overall[1], Kappa = knn_cm$overall[2])
performance_df <- rbind(performance_df, perf_knn)
knn_cm
```

## Multinomial Naive Bayes

```{r message=FALSE, warning=FALSE}
nb <- multinomial_naive_bayes(select(mnist_raw, -X1), as.factor(mnist_raw$X1), laplace=5)
summary(nb)
nb_pred <- predict(nb, newdata = data.matrix(select(mnist_raw_test, -X1)), type = "class")
nb_cm <- confusionMatrix(nb_pred, as.factor(mnist_raw_test$X1))
perf_nb <- data.frame(Model = "Naive Bayes", Accuracy = nb_cm$overall[1], Kappa = nb_cm$overall[2])
performance_df <- rbind(performance_df, perf_nb)
nb_cm
```

## Random Forest

```{r}
rf <- randomForest(x = X_train , y = y_train, ntree = 200)
plot(rf)
```

```{r}
rf_pred <- predict(rf, newdata = X_test, type = "class")
rf_cm <- confusionMatrix(rf_pred, as.factor(y_test))
perf_rf <- data.frame(Model = "Random Forests", Accuracy = rf_cm$overall[1], Kappa = rf_cm$overall[2])
performance_df <- rbind(performance_df, perf_rf)
rf_cm
```

```{r}
varImpPlot(rf)
```

## Gradient Boosting

With gradient boosting, trees are grown in a sequential way using information from previously grown trees. Boosting does not involve bootstrap sampling, instead each tree is fit on a modified version of the original data set. Unlike fitting a single large decision tree (fitting the data hard) which can lead to overfitting, the boosting approach learns slowly. Given a current model, a decision tree is fit to the residuals from the model. Each of these trees can be rather small, with just a few terminal nodes (determined by the interaction depth parameter). By fitting small trees to the residuals, we slowly improve our estimate in areas where it does not perform well. The shrinkage parameter further slows the process down. Cross-validation over 3 folds was used to determine the optimal number of trees. This model reached 94.3% accuracy.

```{r}
gbmGrid <-  expand.grid(interaction.depth = 9, 
                        n.trees = (1:10)*50, 
                        shrinkage = 0.1,
                        n.minobsinnode = 20)

trControl <- trainControl(method  = "cv", number  = 3)

gbm.fit <- train(X_train, y_train,
             method     = "gbm",
             tuneGrid   = gbmGrid,
             trControl  = trControl,
             verbose    = FALSE)
```

```{r}
plot(gbm.fit)
```

```{r}
gbm_pred <- predict(gbm.fit, newdata = X_test)
gbm_cm <- confusionMatrix(gbm_pred, as.factor(y_test))
perf_gbm <- data.frame(Model = "Gradient Boosting", Accuracy = gbm_cm$overall[1], Kappa = gbm_cm$overall[2])
performance_df <- rbind(performance_df, perf_gbm)
gbm_cm
```

# Results

The results are displayed below.

```{r}
rownames(performance_df) <- NULL
performance_df 
```

We can take a look at some of the misclassified instances to evaluate where the model might have gone wrong. On the tile plot below, the predicted number is on the top of the cell, and the actualy digit just below it. We see that most of the instances are obvious mistakes. Other than the middle 6 and 8 and the last 7 which are faily distorted, the other digits remain easily disinguishable to our eyes. 

```{r}
misclass <- data.frame(knn_pred=knnPredict,y_test=y_test)
misclass <- misclass %>% mutate(row=row_number()) %>% filter(knn_pred != y_test) 
# filter misclassified instances
sub_test <- mnist_subset[-trainIndex,]
sub_test <- sub_test[misclass$row,]
sub_test$pred <- misclass$knn_pred
# Display example instances
pixels_gathered <- sub_test %>%  gather(pixel, value, -label, -instance, -pred) %>%  tidyr::extract(pixel, "pixel", "(\\d+)", convert = TRUE) %>%  mutate(pixel = pixel - 2, x = pixel %% 28, y = 28 - pixel %/% 28)
theme_set(theme_light())
pixels_gathered %>%  filter(instance <= 745) %>%  ggplot(aes(x, y, fill = value)) +  geom_tile() +  facet_wrap(~ pred + label) + scale_fill_gradient(low = "white", high = "black")
```

