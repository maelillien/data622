---
title: "DATA 622 Final Project - Image Classification"
author: "Mael Illien, Dhairav Chhatbar, Santosh Manjrekar"
date: "5/7/2021"
output: 
  html_document:
    code_folding: hide
    theme: cosmo
    highlight: tango
    toc: true
    number_section: false
    toc_float:
      collapsed: true
      smooth_scroll: true
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup

```{r message=FALSE, warning=FALSE}
library(skimr)
library(tidyverse)
library(gridExtra)
library(readr)
library(dplyr)
library(caret)
library(naivebayes)
library(factoextra) # For PCA plots
library(e1071)
library(Rtsne)
library(RColorBrewer)
library(gbm)
library(randomForest)
```

# Data Description

```{r message=FALSE, warning=FALSE}
mnist_raw <- read_csv("https://pjreddie.com/media/files/mnist_train.csv", col_names = FALSE)
mnist_raw_test <- read_csv("https://pjreddie.com/media/files/mnist_test.csv", col_names = FALSE)
```

The MNIST dataset is a compilation of handwritten digits which have been digitzed for use in supervised machine learning classification applications. The datset is fairly large with 60,000 observations where each observation is a handwritten digit from various subjects. As a result of this diversity, each handwritten digit of the same number can have differences due to penmanship style and variation within the same penmanship style.

Each handwritten digit is on a 28x28 pixel image. The digits per observation range from 0 to 9 where each observation/digit in the 28x28 pixel have had their size normalized and have been centered on the image canvas. 

Below is a sample of observations from the dataset. Note that the images are grayscale. Each every pixel on the canvas is represented by a integer range from 0 to 255, where 0 means the pixel is completely white and 255 means the pixel is completely black, the ranges from 1 to 254 are the various shades of the color gray. Since each image is 28x28 pixels in size, then each image can be represented by a 28x28 size matrix. 

To represent each matrix as an observation, each digit matrix has been flattened (converting from a multidimensional array to a single dimensional array) such that each observation is a integer list of ($28x28=784$) length 784, where each value in the list is the pixel value ranging from 0 to 255. This list has an additional value which contains a number from the range 0-9 containing the label value of the number represented by the image, bringing the length per observation to 785.  
  
Bringing this all together, the dataset has 60,000 observations, 784 features and 1 classification label. The dataset of digital images is now represented mathematically that we can perform additional analysis and modeling on it. To ease computation time, a subset of 5,000 observations was used in this modeling exercise.

```{r}
# Reduce the dataset down from 60,000 observations
mnist_subset <- mnist_raw %>%  head(5000)
# Relabel X1 and add instance number
mnist_subset <- mnist_subset  %>%  rename(label = X1) %>%  mutate(instance = row_number())
# Split dataset into X and y
X <- mnist_subset %>% select(contains('X'))
y <- mnist_subset$label 
# Display example instances
pixels_gathered <- mnist_subset %>%  gather(pixel, value, -label, -instance) %>%  tidyr::extract(pixel, "pixel", "(\\d+)", convert = TRUE) %>%  mutate(pixel = pixel - 2, x = pixel %% 28, y = 28 - pixel %/% 28)
theme_set(theme_light())
pixels_gathered %>%  filter(instance <=12) %>%  ggplot(aes(x, y, fill = value)) +  geom_tile() +  facet_wrap(~ instance + label) + scale_fill_gradient(low = "white", high = "black")
```


# Data Exploration

The distribution of the draw of 5,000 samples from dataset is displayed below. The distribution is fairly even, though we note that the number 2 is largely more represented than the number 5. The majority of points are either 0 (white) or 255 (black). Most values are not useful which suggest that some dimensionality reduction methods might be useful. 

```{r}
plot1 <- ggplot(mnist_subset, aes(label)) + geom_bar(fill="steelblue")
plot2 <- ggplot(pixels_gathered, aes(value)) +  geom_histogram(bins=256, fill="steelblue")
grid.arrange(plot1, plot2, ncol=2)
```

The figure below is a representation of the average pixels values for the 10 digits in the dataset. The fuzzy, grey areas are zones of high variability. We can notice the most variability in the tails and long strokes of some digits. On the othre hand, some digits such as 0 and 1 have highler pixel concrentrations. 

```{r message=FALSE, warning=FALSE}
pixel_summary <- pixels_gathered %>%  group_by(x, y, label) %>%  summarize(mean_value = mean(value)) %>%  ungroup()
pixel_summary %>%  ggplot(aes(x, y, fill = mean_value)) +  geom_tile() +  scale_fill_gradient2(low = "white", high = "black", mid = "gray", midpoint = 127.5) +  facet_wrap(~ label, nrow = 2) +  labs(title = "Average value of each pixel in 10 MNIST digits", fill = "Average value") +  theme_void()
```

MI: thinking of removing this

```{r}
digit_differences <- crossing(compare1 = 0:9, compare2 = 0:9) %>%  filter(compare1 != compare2) %>%  mutate(negative = compare1, positive = compare2) %>%  gather(class, label, positive, negative) %>%  inner_join(pixel_summary, by = "label") %>%  select(-label) %>%  spread(class, mean_value)
ggplot(digit_differences, aes(x, y, fill = positive - negative)) +  geom_tile() +  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = .5) +  facet_grid(compare2 ~ compare1) +  theme_void() +  labs(title = "Pixels that distinguish pairs of MNIST images")
```



```{r}
x <- 8
cat("Label: ", mnist_raw$X1[x], "\n")
m <- t(matrix(mnist_raw[x,] %>% select(-X1), ncol = 28))
dimnames(m) <-list(rep("", dim(m)[1]), rep("", dim(m)[2]))
m

```


T-SNE Visual
```{r}

tsne_v <- Rtsne(as.matrix(select(mnist_subset, -label)), dims=2, check_duplicates = FALSE, pca = TRUE, pca_scale = FALSE, theta = 0.1 , perplexity = 45)
tsne_coords = data.frame(X=tsne_v$Y[,1], Y=tsne_v$Y[,2], Label=as.factor(mnist_subset$label))
ggplot(tsne_coords, aes(x=X, y=Y, color=Label)) + geom_point(size = 1) + scale_color_brewer(palette = "Set3") + theme_dark()
```


# Data Processing

## Dimensionality Reduction

Two dimensionality reduction methods are explore, Near-Zero Variance (NVZ) and Principal Component Analysis (PCA).

### Near Zero Variance

The near zero variance method looks at the distribution of variables across the dataset and identifies features with low percentages of unique values. These variables are essentially constants and contain no information. As previously shown, the dataset is sparse and the majority of the pixels are always zero. The resulsting dataset retains only 250 variables.

```{r}
nonzero_var <- nearZeroVar(X, saveMetrics = FALSE)
image(matrix(1:784 %in% nonzero_var, 28, 28))
```

```{r}
X <- mnist_subset[ , -nonzero_var]
X <- select(X, -instance)
```

### PCA

Principal Component Analysis (PCA) is a dimensionality reduction technique where a dataset is transformed to use p eigenvectors of the covariance matrix instead of the original number of predictors n, where p < n. The number of eigenvectors p is selected by looking at the sorted eigenvalues and determining a threshold percentage of variance explained and the resulting p.  

The method seeks to project the data into a lower dimensional space where each axis (or principal component) captures the most variability in the data subject to the condition of being uncorrelated to the other axes. This last condition is important for dimensionality reduction in the sense that large datasets can contain many correlated variables which hold no additional information.

```{r}
pca <- prcomp(select(mnist_subset, -label), center = TRUE, scale = FALSE)
qqnorm(pca[["x"]][,1])
```

```{r}
pca %>% get_eigenvalue() %>% head(10)
```

```{r}
pca %>% fviz_eig(addlabels = TRUE)
```


```{r}
get_eigenvalue(pca) %>% filter(eigenvalue > 1)
```

```{r}
reduced_dim_95 <- get_eigenvalue(pca) %>% filter(cumulative.variance.percent < 95.02)
reduced_dim_95

#mnist_pca_reduced <- cbind(as.data.frame(pca$x[,c(1:nrow(reduced_dim_95))]), Label = mnist_raw$X1)
mnist_pca_reduced <- as.data.frame(pca$x[,c(1:nrow(reduced_dim_95))])
head(mnist_pca_reduced)
```

# Modeling


```{r message=FALSE, warning=FALSE}
# Data Partitioning
set.seed(622)
trainIndex <- createDataPartition(y, p = .8, list = FALSE, times = 1)
X_train <- X[trainIndex,]
y_train <- y[trainIndex]
X_test <- X[-trainIndex,]
y_test <- y[-trainIndex]
y_train <- as.factor(y_train)
y_test <- as.factor(y_test)
```

```{r}
performance_df <- data.frame(Model = NULL, Accuracy = NULL, Kappa = NULL)
```


## KNN

The KNN algorithm uses distance between observation points to determine their classification. It is typical to scale the variables in order to even out the influence of variables with large values. In our case, all variables are already on the same scale so no additional processing is required.

```{r message=FALSE, warning=FALSE}
trControl <- trainControl(method  = "cv", number  = 3)
knn.fit <- train(X_train, y_train,
             method     = "knn",
             tuneGrid   = expand.grid(k = 1:5),
             trControl  = trControl)
```


```{r}
plot(knn.fit)
```

```{r}
knnPredict <- predict(knn.fit, newdata = X_test) 
knn_cm <- confusionMatrix(knnPredict, y_test)
perf_knn <- data.frame(Model = "KNN", Accuracy = knn_cm$overall[1], Kappa = knn_cm$overall[2])
performance_df <- rbind(performance_df, perf_knn)
knn_cm
```


## Multinomial Naive Bayes

```{r message=FALSE, warning=FALSE}
nb <- multinomial_naive_bayes(select(mnist_raw, -X1), as.factor(mnist_raw$X1), laplace=5)
summary(nb)
nb_pred <- predict(nb, newdata = data.matrix(select(mnist_raw_test, -X1)), type = "class")
nb_cm <- confusionMatrix(nb_pred, as.factor(mnist_raw_test$X1))
perf_nb <- data.frame(Model = "Naive Bayes", Accuracy = nb_cm$overall[1], Kappa = nb_cm$overall[2])
performance_df <- rbind(performance_df, perf_nb)
nb_cm
```

## Random Forest

```{r}
rf <- randomForest(x = X_train , y = y_train, ntree = 200)
plot(rf)
```

```{r}
rf_pred <- predict(rf, newdata = X_test, type = "class")
rf_cm <- confusionMatrix(rf_pred, as.factor(y_test))
perf_rf <- data.frame(Model = "Random Forests", Accuracy = rf_cm$overall[1], Kappa = rf_cm$overall[2])
performance_df <- rbind(performance_df, perf_rf)
rf_cm
```

```{r}
varImpPlot(rf)
```

## Gradient Boosting


```{r}
gbmGrid <-  expand.grid(interaction.depth = 9, 
                        n.trees = (1:10)*25, 
                        shrinkage = 0.1,
                        n.minobsinnode = 20)

trControl <- trainControl(method  = "cv", number  = 3)

gbm.fit <- train(X_train, y_train,
             method     = "gbm",
             tuneGrid   = gbmGrid,
             trControl  = trControl,
             verbose=FALSE)
```

```{r}
plot(gbm.fit)
```

```{r}
gbm_pred <- predict(gbm.fit, newdata = X_test)
gbm_cm <- confusionMatrix(gbm_pred, as.factor(y_test))
perf_gbm <- data.frame(Model = "Gradient Boosting", Accuracy = gbm_cm$overall[1], Kappa = gbm_cm$overall[2])
performance_df <- rbind(performance_df, perf_gbm)
gbm_cm
```

# Results

```{r}
rownames(performance_df) <- NULL
performance_df 
```

```{r}
misclass <- data.frame(knn_pred=knnPredict,y_test=y_test)
misclass <- misclass %>% mutate(row=row_number()) %>% filter(knn_pred != y_test) 
# filter misclassified instances
sub_test <- mnist_subset[-trainIndex,]
sub_test <- sub_test[misclass$row,]
sub_test$pred <- misclass$knn_pred
# Display example instances
pixels_gathered <- sub_test %>%  gather(pixel, value, -label, -instance, -pred) %>%  tidyr::extract(pixel, "pixel", "(\\d+)", convert = TRUE) %>%  mutate(pixel = pixel - 2, x = pixel %% 28, y = 28 - pixel %/% 28)
theme_set(theme_light())
pixels_gathered %>%  filter(instance <= 745) %>%  ggplot(aes(x, y, fill = value)) +  geom_tile() +  facet_wrap(~ pred + label) + scale_fill_gradient(low = "white", high = "black")
```

